# Spring MVC

## Jakarta EE

原来的名字是JavaEE是Java Platform Enterprise Edition的缩写，即Java企业平台。完全基于JavaSE，只是多了一大堆服务器相关的库以及API接口。

依赖项`jakarta.servlet:jakarta.servlet-api`

### Servlet

Servlet是JavaEE平台上处理HTTP的类.

```java
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.io.PrintWriter;

/**
 * 所有Servlet都继承HttpServlet
 * urlPatterns表示访问路径
 */
@WebServlet(urlPatterns = "/")
public class HelloServlet extends HttpServlet {
    /**
     * 
     * @param req HTTP 请求
     * @param resp HTTP 返回
     */
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        PrintWriter writer = resp.getWriter();
        writer.write("<html><body>");
        writer.write("<h1>Hello World!</h1>");
        writer.write("</body></html>");
        writer.flush();
        writer.close();
    }
}

```

通过嵌入式Tomcat运行Servlet, 依赖项`org.apache.tomcat.embed:tomcat-embed-core`

直接运行servlet
```java

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.catalina.Context;
import org.apache.catalina.LifecycleException;
import org.apache.catalina.connector.Connector;
import org.apache.catalina.startup.Tomcat;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;

public class Main {

    public static void main(String[] args) throws LifecycleException {
        Tomcat tomcat = new Tomcat();
        // 手动创建Connector, 如果要tomcat创建默认Connector, 需要调用tomcat.getConnector()才会创建
        Connector connector = new Connector();
        connector.setPort(8080);
        tomcat.setConnector(connector);

        Context context = tomcat.addContext("", new File("mvc/src/main/webapp").getAbsolutePath());
        Tomcat.addServlet(context, "MVC", new HttpServlet() {
            @Override
            protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
                PrintWriter writer = resp.getWriter();
                writer.write("<html><body>");
                writer.write("<h1>Hello World!</h1>");
                writer.write("</body></html>");
                writer.flush();
                writer.close();
            }
        });
        context.addServletMappingDecoded("/*", "MVC");
        tomcat.start();
        tomcat.getServer().await();
    }
}
```

运行war包, 添加war包的构建插件
```kotlin
plugins {
    id("war")
}
```
打代码成war包

```java
import org.apache.catalina.Context;
import org.apache.catalina.LifecycleException;
import org.apache.catalina.connector.Connector;
import org.apache.catalina.startup.Tomcat;

import java.io.File;

public class Main {

    public static void main(String[] args) throws LifecycleException {
        Tomcat tomcat = new Tomcat();
        // 手动创建Connector, 如果要tomcat创建默认Connector, 需要调用tomcat.getConnector()才会创建
        Connector connector = new Connector();
        connector.setPort(8080);
        tomcat.setConnector(connector);

        Context context = tomcat.addWebapp("", new File("mvc/build/libs/mvc-1.0-SNAPSHOT.war").getAbsolutePath());
        tomcat.start();
        tomcat.getServer().await();
    }
}
```

### JSP

添加依赖`org.apache.tomcat.embed:tomcat-embed-jasper`, JSP的本质还是一个Servlet, 是通过`org.apache.tomcat.embed:tomcat-embed-jasper`在访问时动态生成的Sevlet实现.

JSP的语法, 与HTML没有太大区别, 在需要插入值的地方使用`<% ... %>`

`<%-- 注释 --%>`: 注释语法
`<% Java代码 %>`: 插入Java代码
`<%=  变量 %>`: 快捷输出变量

内置变量:
- out: HttpServletResponse的PrintWriter
- session: 表示当前HttpSession对象
- equest: 表示HttpServletRequest对象

高级功能:
`<%@ page import="java.io.File" %>`: 导入Java类
`<%@ include file="header.jsp"%>`: 引入其他JSP文件

### 结合Servlet和JSP

User类的定义
```java
public class User {
    public long id;
    public String name;
    public String picture;
}
```

```java
@WebServlet(urlPatterns = "/user")
public class UserServlet extends HttpServlet {
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 创建User类
        User user = new User(123, "Bob", "https://example.com/1.png");
        // 放入Request中
        req.setAttribute("user", user);
        // WEB-INF是一个特殊目录，Web Server会阻止浏览器对WEB-INF目录下任何资源的访问，这样就防止用户通过/user.jsp路径直接访问到JSP页面
        // forward给user.jsp
        req.getRequestDispatcher("/WEB-INF/user.jsp").forward(req, resp);
    }
}

```

```jsp
<%@ page import="User"%>
<%
    User user = (User) request.getAttribute("user");
%>
<html>
<head>
    <title>Hello World - JSP</title>
</head>
<body>
    <h1>Hello <%= user.name %>!</h1>
</body>
</html>
```

### Filter

```java
/**
 * Filter 拦截请求和修改请求
 */
@WebFilter("/user")
public class UserFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("UserFilter HostName: " + servletRequest.getRemoteHost());
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        String userName = request.getHeader("user");
        if (Objects.equals(userName, "shug")) {
            filterChain.doFilter(servletRequest, servletResponse);
        } else {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.setContentType("text/html;charset=utf-8");
            PrintWriter writer = response.getWriter();
            writer.write("<html>");
            writer.write("<head>");
            writer.write("</head>");
            writer.write("<body>");
            writer.write("无效用户");
            writer.write("</body>");
            writer.write("</html>");
        }
    }
}
```

### Listener
使用WebListener注解, 并实现特定接口的类, 才能监听事件.

- ServletContextListener: 整个Web应用程序初始化完成后，以及Web应用程序关闭后获得回调通知
- HttpSessionListener: 监听HttpSession的创建和销毁事件；
- ServletRequestListener: 监听ServletRequest请求的创建和销毁事件；
- ServletRequestAttributeListener: 监听ServletRequest请求的属性变化事件（即调用ServletRequest.setAttribute()方法）；
- ServletContextAttributeListener: 监听ServletContext的属性变化事件（即调用ServletContext.setAttribute()方法）；


## Spring

Java有许多MVC框架, Spring MVC只是其中的一种.

### 开启Spring MVC

```java
public class Main {
    public static void main(String[] args) throws LifecycleException {
        Tomcat tomcat = new Tomcat();
        // 手动创建Connector, 如果要tomcat创建默认Connector, 需要调用tomcat.getConnector()才会创建
        Connector connector = new Connector();
        connector.setPort(8080);
        tomcat.setConnector(connector);
        Context context = tomcat.addWebapp("", new File("mvc/src/main/webapp").getAbsolutePath());
        // 创建 DispatcherServlet
        DispatcherServlet servlet = new DispatcherServlet();
        // 配置Spring容器
        servlet.setContextClass(org.springframework.web.context.support.AnnotationConfigWebApplicationContext.class);
        servlet.setContextConfigLocation("site.shug.spring.mvc.config.WebConfig"); // 配置类
        Tomcat.addServlet(context, "MVC", servlet);
        context.addServletMappingDecoded("/*", "MVC");
        tomcat.start();
        tomcat.getServer().await();
    }
}
```

```java
@Configuration
@ComponentScan(basePackages = "site.shug.spring.mvc")
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {
}

```

`EnableWebMvc`开启Spring MVC的功能, 实际导入的是`DelegatingWebMvcConfiguration`这个`WebMvcConfigurationSupport`的默认子类, 实现`WebMvcConfigurer`可以完成以下自定义功能, 如果不使用`EnableWebMvc`, 可以继承`WebMvcConfigurationSupport`或`DelegatingWebMvcConfiguration`.


```java
/**
 * Controller 主要用于返回视图（通常是HTML、JSP等）或处理请求并返回模型数据。
 * ResponseBody 返回纯数据而不是视图
 * RestController = Controller + ResponseBody
 */
@Controller
public class HelloController {
    @GetMapping("/hello")
    public String sayHello() {
        return "hello";
    }
}
```

要支持Json需要加入依赖`com.fasterxml.jackson.core:jackson-databind`.

### 结合Spring和Servlet

在Filter中使用Spring的Bean

```java
@Configuration
@ComponentScan(basePackages = "site.shug.spring.mvc")
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer, WebApplicationInitializer {
    /**
     * DelegatingFilterProxy可以将Spring容器的Bean在Filter中使用
     */
    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {
        System.out.println("OnStartup");
        DelegatingFilterProxy proxy = new DelegatingFilterProxy();
        // 代理Bean的名称
        proxy.setTargetBeanName("myResponseFilter");
        FilterRegistration.Dynamic filter = servletContext.addFilter("MyFilter", proxy);
        filter.addMappingForUrlPatterns(null, false, "/*");
    }
}

```

### Interceptor

在Spring MVC中可以使用`Interceptor`, 代替`Filter`,两者的不同是`Filter`在`DispatcherServlet`之前工作, `Interceptor`在`DispatcherServlet`和`DispatcherServlet`之间.

使用`Interceptor`由Spring容器管理, 注入Bean十分简单. 并且多个`Interceptor`可以通过`@Order`指定顺序.

```java
@Component
public class SayByeHandlerInterceptor implements HandlerInterceptor {
    /**
     * Controller方法调用前执行
     * @param request 当前请求
     * @param response 响应
     * @param handler chosen handler to execute, for type and/or instance evaluation
     * @return false表示不再调用Controller, true表示继续执行
     * @throws Exception 异常信息
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 在Controller处理前, 才能修改HttpServletResponse的Header
        response.setHeader("say", "bye");
        return HandlerInterceptor.super.preHandle(request, response, handler);
    }

    /**
     * Controller方法正常返回后
     * @param request 当前请求
     * @param response 响应
     * @param handler Controller的方法
     * @param modelAndView Controller返回的ModelAndView, 如果Controller不是返回的ModelAndView, 则为null
     * @throws Exception 异常信息
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
    }

    /**
     * 无论Controller方法是否抛异常都会执行
     * @param request 当前请求
     * @param response Controller的方法
     * @param handler Controller的方法
     * @param ex Controller返回的异常
     * @throws Exception 异常信息
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
    }
}
```

注册HandlerInterceptor

```java
    /**
     * 注册所有HandlerInterceptor
     */
    @Bean
    public WebMvcConfigurer createWebMvcConfigurer(HandlerInterceptor[] handlerInterceptors) {
        return new WebMvcConfigurer() {
            public void addInterceptors(InterceptorRegistry registry) {
                for (HandlerInterceptor interceptor : handlerInterceptors) {
                    registry.addInterceptor(interceptor);
                }
            }
        };
    }
```

`ExceptionHandler`异常处理方法

```java
@RestController
public class UserController {
    @GetMapping("/ex")
    public void ex() {
        throw new RuntimeException("产生异常");
    }
    /**
     * 仅可以捕获当前Controller的异常
     * @param e 没有固定参数可以传入Exception, HttpServletRequest等,
     * 返回值可以是void, ModelAndView
     */
    @ExceptionHandler(RuntimeException.class)
    public void handlerException(Exception e) {
        System.out.println("catch RuntimeException: " + e.getMessage());
    }
}

```

捕获其他Controller的异常
```java
@RestControllerAdvice
public class MyControllerAdvice {
    @ExceptionHandler(value = Exception.class)
    Map<String, String> handler(Exception e) {
        Map<String, String> map = new HashMap<>();
        map.put("msg", e.getMessage());
        return map;
    }
}

```

### CORS

使用`CrossOrigin`处理Controller级别的跨域请求
```java
@CrossOrigin(origins = "*")
@RestController
@RequestMapping("/api")
public class ApiController {
}
```

全局CORS配置

```java
    @Bean
    public WebMvcConfigurer createWebMvcConfigurer(HandlerInterceptor[] handlerInterceptors) {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**")
                        .allowedOrigins("*")
                        .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                        .maxAge(3600);
            }
        };
    }
```

### 国际化

Spring MVC通过`LocaleResolver`来自动从`HttpServletRequest`中获取`Locale`。有多种LocaleResolver的实现类，其中最常用的是`CookieLocaleResolver`

```java
@Primary
@Bean
LocaleResolver createLocaleResolver() {
    var clr = new CookieLocaleResolver();
    clr.setDefaultLocale(Locale.ENGLISH);
    clr.setDefaultTimeZone(TimeZone.getDefault());
    return clr;
}
```

创建`MessageSource`
```java
    @Bean("i18n")
    MessageSource createMessageSource() {
        var messageSource = new ResourceBundleMessageSource();
        // 指定文件是UTF-8编码:
        messageSource.setDefaultEncoding("UTF-8");
        // 指定主文件名:
        messageSource.setBasename("messages");
        return messageSource;
    }
```

使用国际化
```java
@RestController("/")
public class UserController {
    @Autowired
    LocaleResolver localeResolver;

    @Autowired
    @Qualifier("i18n")
    MessageSource messageSource;

    @GetMapping("/say")
    public String sayHello(HttpServletRequest request) {
        Locale locale = localeResolver.resolveLocale(request);
        return messageSource.getMessage("say", null, locale);
    }

}

```

### WebSocket

WebSocket是一种基于HTTP的长链接技术。依赖项`org.springframework:spring-websocket`和`org.apache.tomcat.embed:tomcat-embed-websocket`,
通过`EnableWebSocket`开启WebSockets.

```java
    @Bean
    WebSocketConfigurer createWebSocketConfigurer(
            @Autowired ChatHandler chatHandler,
            @Autowired ChatHandshakeInterceptor chatInterceptor)
    {
        return new WebSocketConfigurer() {
            public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
                // 把URL与指定的WebSocketHandler关联，可关联多个:
                registry.addHandler(chatHandler, "/chat").addInterceptors(chatInterceptor);
            }
        };
    }
```

`ChatHandler`和`ChatHandshakeInterceptor`的代码

```java
@Component
public class ChatHandler extends TextWebSocketHandler {
    private Map<String, WebSocketSession> clients = new ConcurrentHashMap<>();

    /**
     * 成功建立连接后执行
     * @param session WebSocket的会话
     * @throws Exception 异常
     */
    @Override
    public void afterConnectionEstablished(WebSocketSession session) {
        clients.put(session.getId(), session);
        System.out.println("afterConnectionEstablished");
        session.getAttributes().put("client", "Guest1");
    }

    /**
     * 连接关闭后执行
     * @param session WebSocket的会话
     * @param status 关闭状态
     * @throws Exception 异常
     */
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
        System.out.println("afterConnectionClosed");
        clients.remove(session.getId());
    }
}

```

```java
@Component
public class ChatHandshakeInterceptor implements HandshakeInterceptor {

    /**
     * WebSocket连接前执行
     * @return 返回false将不再继续执行
     */
    @Override
    public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map<String, Object> attributes) throws Exception {
        System.out.println("beforeHandshake");
        return true;
    }

    /**
     * WebSocket连接后执行
     */
    @Override
    public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception exception) {
        System.out.println("afterHandshake");
    }
}

```