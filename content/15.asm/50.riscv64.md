# RISCV64

RISC-V 是一种开源的指令集架构，由加州大学伯克利分校的计算机科学家开发。与其他专有架构（如 ARM 或 x86）不同，RISC-V 完全开源，允许任何人使用、修改和扩展。

## 寄存器

RISC-V 64位架构（riscv64）拥有一组32个通用寄存器和若干个特定用途寄存器，每个寄存器都是64位宽。以下是 RISC-V 64位架构的寄存器的详细说明：

### 通用寄存器
RISC-V 64位架构的32个通用寄存器由 x0 到 x31 表示，每个寄存器都有特定的用途和惯例名称：

1. **x0 (zero)**：常值 0
2. **x1 (ra, return address)**：返回地址
3. **x2 (sp, stack pointer)**：栈指针
4. **x3 (gp, global pointer)**：全局指针
5. **x4 (tp, thread pointer)**：线程指针
6. **x5 - x7 (t0 - t2, temporary registers)**：临时寄存器，不需要在函数调用间保存
7. **x8 (s0/fp, saved register/frame pointer)**：保存寄存器/帧指针
8. **x9 (s1, saved register)**：保存寄存器
9. **x10 - x11 (a0 - a1, function arguments/return values)**：函数参数/返回值
10. **x12 - x17 (a2 - a7, function arguments)**：函数参数
11. **x18 - x27 (s2 - s11, saved registers)**：保存寄存器
12. **x28 - x31 (t3 - t6, temporary registers)**：临时寄存器

### 寄存器用途和描述

| 寄存器 | 名称    | 用途                          |
|--------|---------|-------------------------------|
| x0     | zero    | 常值 0                         |
| x1     | ra      | 返回地址                       |
| x2     | sp      | 栈指针                         |
| x3     | gp      | 全局指针                       |
| x4     | tp      | 线程指针                       |
| x5     | t0      | 临时寄存器                     |
| x6     | t1      | 临时寄存器                     |
| x7     | t2      | 临时寄存器                     |
| x8     | s0/fp   | 保存寄存器/帧指针              |
| x9     | s1      | 保存寄存器                     |
| x10    | a0      | 函数参数/返回值                |
| x11    | a1      | 函数参数/返回值                |
| x12    | a2      | 函数参数                       |
| x13    | a3      | 函数参数                       |
| x14    | a4      | 函数参数                       |
| x15    | a5      | 函数参数                       |
| x16    | a6      | 函数参数                       |
| x17    | a7      | 函数参数                       |
| x18    | s2      | 保存寄存器                     |
| x19    | s3      | 保存寄存器                     |
| x20    | s4      | 保存寄存器                     |
| x21    | s5      | 保存寄存器                     |
| x22    | s6      | 保存寄存器                     |
| x23    | s7      | 保存寄存器                     |
| x24    | s8      | 保存寄存器                     |
| x25    | s9      | 保存寄存器                     |
| x26    | s10     | 保存寄存器                     |
| x27    | s11     | 保存寄存器                     |
| x28    | t3      | 临时寄存器                     |
| x29    | t4      | 临时寄存器                     |
| x30    | t5      | 临时寄存器                     |
| x31    | t6      | 临时寄存器                     |

### 特殊用途寄存器

除了通用寄存器外，RISC-V 64位架构还定义了一些特殊用途寄存器（CSR，Control and Status Registers），用于控制和状态管理。常见的特殊用途寄存器包括：

1. **mstatus**：机器状态寄存器
2. **mtvec**：机器陷阱向量寄存器
3. **mepc**：机器异常程序计数器
4. **mcause**：机器异常原因寄存器
5. **mscratch**：机器临时寄存器

这些寄存器在操作系统和异常处理程序中扮演重要角色。

### 示例代码

以下是一个简单的 RISC-V 64位汇编程序示例，它实现了两个数的加法并将结果存储在一个寄存器中：

```asm
.section .data
num1:   .dword 5       // 定义第一个数
num2:   .dword 10      // 定义第二个数

.section .text
.globl _start
_start:
    ld x10, num1       // 加载num1到寄存器x10
    ld x11, num2       // 加载num2到寄存器x11
    add x12, x10, x11  // 将x10和x11相加，结果存储到x12

    // 退出程序（假设在一个支持的模拟器或操作系统中运行）
    li a7, 93          // ecall退出系统调用号（Linux）
    ecall              // 执行系统调用
```

在这个示例中，伪指令 `li` 和加载指令 `ld` 被使用来简化代码的编写和阅读。

## 指令

RISC-V 64位架构（RV64）的指令集设计简洁、模块化，包含了各种基础指令以及可选的扩展指令。以下是 RISC-V 64位架构的基本指令集（RV64I）的一些常见指令和说明：

### 指令格式
RISC-V 的指令格式分为以下几种主要类型：

1. **R型指令**：用于寄存器到寄存器的运算。
2. **I型指令**：用于立即数运算和内存加载。
3. **S型指令**：用于内存存储。
4. **B型指令**：用于条件分支。
5. **U型指令**：用于加载高位立即数。
6. **J型指令**：用于跳转。

### R型指令
R型指令用于寄存器之间的算术和逻辑运算。格式如下：
```
opcode | rd | funct3 | rs1 | rs2 | funct7
```
- `rd`：目标寄存器。
- `rs1`：第一个源寄存器。
- `rs2`：第二个源寄存器。
- `funct3` 和 `funct7`：指定具体操作。

常见 R型指令：
```asm
add  rd, rs1, rs2  // rd = rs1 + rs2
sub  rd, rs1, rs2  // rd = rs1 - rs2
and  rd, rs1, rs2  // rd = rs1 & rs2
or   rd, rs1, rs2  // rd = rs1 | rs2
xor  rd, rs1, rs2  // rd = rs1 ^ rs2
sll  rd, rs1, rs2  // rd = rs1 << rs2 (逻辑左移)
srl  rd, rs1, rs2  // rd = rs1 >> rs2 (逻辑右移)
sra  rd, rs1, rs2  // rd = rs1 >>> rs2 (算术右移)
```

### I型指令
I型指令用于立即数运算和内存加载。格式如下：
```
opcode | rd | funct3 | rs1 | imm
```
- `imm`：立即数。

常见 I型指令：
```asm
addi  rd, rs1, imm   // rd = rs1 + imm
andi  rd, rs1, imm   // rd = rs1 & imm
ori   rd, rs1, imm   // rd = rs1 | imm
xori  rd, rs1, imm   // rd = rs1 ^ imm
slli  rd, rs1, shamt // rd = rs1 << shamt (逻辑左移)
srli  rd, rs1, shamt // rd = rs1 >> shamt (逻辑右移)
srai  rd, rs1, shamt // rd = rs1 >>> shamt (算术右移)
ld    rd, imm(rs1)   // 从内存地址rs1+imm加载双字到rd
lb    rd, imm(rs1)   // 从内存地址rs1+imm加载字节到rd
lh    rd, imm(rs1)   // 从内存地址rs1+imm加载半字到rd
lw    rd, imm(rs1)   // 从内存地址rs1+imm加载字到rd
```

### S型指令
S型指令用于内存存储。格式如下：
```
opcode | imm[11:5] | rs2 | rs1 | funct3 | imm[4:0]
```
常见 S型指令：
```asm
sd  rs2, imm(rs1)  // 将rs2存储到内存地址rs1+imm
sb  rs2, imm(rs1)  // 将rs2的低8位存储到内存地址rs1+imm
sh  rs2, imm(rs1)  // 将rs2的低16位存储到内存地址rs1+imm
sw  rs2, imm(rs1)  // 将rs2的低32位存储到内存地址rs1+imm
```

### B型指令
B型指令用于条件分支。格式如下：
```
opcode | imm[12] | imm[10:5] | rs2 | rs1 | funct3 | imm[4:1] | imm[11]
```
常见 B型指令：
```asm
beq   rs1, rs2, offset  // 如果rs1 == rs2，则跳转到当前地址加上offset
bne   rs1, rs2, offset  // 如果rs1 != rs2，则跳转到当前地址加上offset
blt   rs1, rs2, offset  // 如果rs1 < rs2，则跳转到当前地址加上offset
bge   rs1, rs2, offset  // 如果rs1 >= rs2，则跳转到当前地址加上offset
bltu  rs1, rs2, offset  // 如果rs1 < rs2（无符号），则跳转到当前地址加上offset
bgeu  rs1, rs2, offset  // 如果rs1 >= rs2（无符号），则跳转到当前地址加上offset
```

### U型指令
U型指令用于加载高位立即数。格式如下：
```
opcode | rd | imm
```
常见 U型指令：
```asm
lui  rd, imm  // 将imm加载到rd的高20位
auipc rd, imm // 将PC+imm加载到rd的高20位
```

### J型指令
J型指令用于跳转。格式如下：
```
opcode | rd | imm
```
常见 J型指令：
```asm
jal  rd, offset  // 跳转到当前地址加上offset，并将返回地址存储到rd
jalr rd, imm(rs1) // 跳转到rs1+imm，并将返回地址存储到rd
```

### 特殊指令
RISC-V 还有一些特殊指令，例如用于系统调用和控制寄存器的指令：
```asm
ecall  // 环境调用，用于系统调用
ebreak // 环境断点，用于调试
csrrw  rd, csr, rs1 // 读写控制状态寄存器
csrrs  rd, csr, rs1 // 读并设置控制状态寄存器
csrrc  rd, csr, rs1 // 读并清除控制状态寄存器
```

### 示例代码
以下是一个简单的 RISC-V 64位汇编程序示例，它实现了两个数的加法并将结果存储在一个寄存器中：
```asm
.section .data
num1:   .dword 5       // 定义第一个数
num2:   .dword 10      // 定义第二个数

.section .text
.globl _start
_start:
    ld x10, num1       // 加载num1到寄存器x10
    ld x11, num2       // 加载num2到寄存器x11
    add x12, x10, x11  // 将x10和x11相加，结果存储到x12

    // 退出程序（假设在一个支持的模拟器或操作系统中运行）
    li a7, 93          // ecall退出系统调用号（Linux）
    ecall              // 执行系统调用
```

## 伪指令

RISC-V 64位架构（RV64）中的伪指令（Pseudo Instructions）是为了简化编程而设计的，它们不是直接由硬件执行的指令，而是由汇编器（Assembler）翻译成一个或多个实际的机器指令。伪指令使得编写汇编代码更简洁和易于理解。以下是一些常见的 RISC-V 64位伪指令及其等效的实际指令：

### 常见伪指令及其等效指令

1. **`li rd, imm`（加载立即数）**
   - 将一个立即数加载到寄存器 `rd`。
   - 等效指令（当立即数较小时）：
     ```asm
     addi rd, x0, imm
     ```
   - 等效指令（当立即数较大时）：
     ```asm
     lui rd, imm[31:12]
     addi rd, rd, imm[11:0]
     ```

2. **`mv rd, rs`（寄存器间移动）**
   - 将寄存器 `rs` 的值复制到寄存器 `rd`。
   - 等效指令：
     ```asm
     addi rd, rs, 0
     ```

3. **`nop`（空操作）**
   - 不执行任何操作。
   - 等效指令：
     ```asm
     addi x0, x0, 0
     ```

4. **`j offset`（无条件跳转）**
   - 跳转到当前地址加上偏移量 `offset`。
   - 等效指令：
     ```asm
     jal x0, offset
     ```

5. **`jr rs`（寄存器无条件跳转）**
   - 跳转到寄存器 `rs` 所指向的地址。
   - 等效指令：
     ```asm
     jalr x0, 0(rs)
     ```

6. **`ret`（返回）**
   - 从子程序返回。
   - 等效指令：
     ```asm
     jalr x0, 0(ra)
     ```

7. **`call label`（调用子程序）**
   - 调用子程序并保存返回地址。
   - 等效指令：
     ```asm
     auipc ra, %pcrel_hi(label)
     jalr ra, %pcrel_lo(label)(ra)
     ```

8. **`tail label`（尾调用）**
   - 跳转到子程序，不保存返回地址。
   - 等效指令：
     ```asm
     auipc x0, %pcrel_hi(label)
     jalr x0, %pcrel_lo(label)(x0)
     ```

### 示例代码
以下是一个使用伪指令的简单 RISC-V 64位汇编程序示例：

```asm
.section .data
num1:   .dword 5       // 定义第一个数
num2:   .dword 10      // 定义第二个数

.section .text
.globl _start
_start:
    li t0, 10          // 将立即数 10 加载到临时寄存器 t0
    li t1, 20          // 将立即数 20 加载到临时寄存器 t1
    add t2, t0, t1     // 将 t0 和 t1 相加，结果存储在 t2
    mv a0, t2          // 将 t2 的值复制到 a0

    // 退出程序（假设在一个支持的模拟器或操作系统中运行）
    li a7, 93          // ecall退出系统调用号（Linux）
    ecall              // 执行系统调用
```
