# RISC-V指令集手册(非特权架构)

[官方网站](https://riscv.org/technical/specifications/)

## 模块
包含的模块:

| 基础指令集 | 版本   | 状态       | 说明                                              |
|------------|--------|------------|---------------------------------------------------|
| **RV32I**  | **2.1**| **批准**   | 32位基础整数指令集                                 |
| **RV32E**  | **2.0**| **批准**   | 32位嵌入式基础整数指令集                           |
| **RV64E**  | **2.0**| **批准**   | 64位嵌入式基础整数指令集                           |
| **RV64I**  | **2.1**| **批准**   | 64位基础整数指令集                                 |
| *RV128I*   | *1.7*  | *草案*     | 128位基础整数指令集（草案）                        |

| 扩展       | 版本   | 状态       | 说明                                              |
|------------|--------|------------|---------------------------------------------------|
| **Zifencei**  | **2.0** | **批准**   | 指令获取栅栏                                      |
| **Zicsr**     | **2.0** | **批准**   | 控制和状态寄存器访问                              |
| **Zicntr**    | **2.0** | **批准**   | 计数器指令                                        |
| **Zihintntl** | **1.0** | **批准**   | 非时序加载提示                                    |
| **Zihintpause**| **2.0**| **批准**   | 暂停提示                                          |
| **Zimop**     | **1.0** | **批准**   | 用于可能操作                                     |
| **Zicond**    | **1.0** | **批准**   | 条件分支提示                                      |
| **M**         | **2.0** | **批准**   | 整数乘法和除法                                    |
| **Zmmul**     | **1.0** | **批准**   | 仅整数乘法                                        |
| **Zaamo**     | **2.1** | **批准**   | 原子内存操作                                      |
| **Zalrsc**    | **2.1** | **批准**   | 加载保留/存储条件指令                              |
| **A**         | **2.1** | **批准**   | 原子操作指令                                      |
| **Zawrs**     | **1.01**| **批准**   | 等待预约设置指令                                   |
| **Zacas**     | **1.0** | **批准**   | 原子比较并交换                                    |
| **RVWMO**     | **2.0** | **批准**   | 放松的内存排序                                    |
| **Ztso**      | **1.0** | **批准**   | 完全存储排序                                      |
| **CMO**       | **1.0** | **批准**   | 缓存管理操作                                      |
| **F**         | **2.2** | **批准**   | 单精度浮点指令                                    |
| **D**         | **2.2** | **批准**   | 双精度浮点指令                                    |
| **Q**         | **2.2** | **批准**   | 四倍精度浮点指令                                  |
| **Zfh**       | **1.0** | **批准**   | 半精度浮点指令                                    |
| **Zfhmin**    | **1.0** | **批准**   | 最小半精度浮点指令                                |
| **Zfa**       | **1.0** | **批准**   | 浮点算术指令                                      |
| **Zfinx**     | **1.0** | **批准**   | 整数寄存器中的单精度浮点指令                      |
| **Zdinx**     | **1.0** | **批准**   | 整数寄存器中的双精度浮点指令                      |
| **Zhinx**     | **1.0** | **批准**   | 整数寄存器中的半精度浮点指令                      |
| **Zhinxmin**  | **1.0** | **批准**   | 最小整数寄存器中的半精度浮点指令                  |
| **C**         | **2.0** | **批准**   | 压缩指令                                          |
| *Zce*         | **1.0** | **批准**   | 嵌入式压缩指令                                    |
| **B**         | **1.0** | **批准**   | 位操作指令                                        |
| *P*           | *0.2*  | *草案*     | 打包SIMD指令（草案）                               |
| **V**         | **1.0** | **批准**   | 矢量扩展                                          |
| *Zbkb*        | **1.0** | **批准**   | 基本位操作指令                                    |
| *Zbkc*        | **1.0** | **批准**   | 无进位乘法指令                                    |
| *Zbkx*        | **1.0** | **批准**   | 位操作扩展                                        |
| *Zk*          | **1.0** | **批准**   | 加密扩展                                          |
| *Zks*         | **1.0** | **批准**   | 标量加密指令                                      |
| *Zvbb*        | **1.0** | **批准**   | 矢量基本位操作指令                                |
| *Zvbc*        | **1.0** | **批准**   | 矢量无进位乘法                                    |
| *Zvkg*        | **1.0** | **批准**   | 矢量加密扩展                                      |
| *Zvkned*      | **1.0** | **批准**   | 矢量加密非加密数据扩展                            |
| *Zvknhb*      | **1.0** | **批准**   | 矢量加密基于哈希的消息认证                        |
| *Zvksed*      | **1.0** | **批准**   | 矢量加密对称加密                                  |
| *Zvksh*       | **1.0** | **批准**   | 矢量加密对称哈希                                  |
| *Zvkt*        | **1.0** | **批准**   | 矢量加密转换                                      |

## 名称解释

-  IALIGN（以位为单位）来指代实现强制执行的指令地址对齐约束。IALIGN 在基本 ISA 中为 32 位，但某些 ISA 扩展（包括压缩的 ISA 扩展）将 IALIGN 放宽至 16 位。 IALIGN 不得采用 16 或 32 以外的任何值。
- ILEN（以位为单位）来指代实现支持的最大指令长度，并且它始终是 IALIGN 的倍数。对于仅支持基本指令集的实现，ILEN 是 32 位。支持较长指令的实现具有较大的 ILEN 值。

## 基本指令格式
RISC-V 所有格式的源（rs1 和 rs2）和目标（rd）寄存器保持在相同位置，以简化解码。除了 CSR 指令中使用的 5 位立即数之外，立即数始终进行符号扩展，并且通常打包到指令中最左边的可用位，并进行分配以降低硬件复杂性。特别是，所有立即数的符号位始终位于指令的位 31 中，以加速符号扩展电路。

### R 型指令格式
R 型指令用于寄存器之间的算术和逻辑运算。
```
31       25  24  20  19  15  14  12  11    7  6      0
+---------+-------+-------+-------+-------+---------+
| funct7  |  rs2  |  rs1  | funct3|   rd  | opcode  |
+---------+-------+-------+-------+-------+---------+
```
- `opcode`：操作码，指定指令类型。
- `rd`：目标寄存器。
- `funct3`：功能码，指定具体操作。
- `rs1`：第一个源寄存器。
- `rs2`：第二个源寄存器。
- `funct7`：功能码，进一步指定具体操作。

### I 型指令格式
I 型指令用于立即数运算和内存加载。
```
31       20  19  15  14  12  11   7  6      0
+----------+-------+-------+-------+-----------------+
|imm[11:0] |  rs1  | funct3|   rd  | opcode          |
+----------+-------+-------+-------+-----------------+
```
- `opcode`：操作码。
- `rd`：目标寄存器。
- `funct3`：功能码。
- `rs1`：源寄存器。
- `imm[11:0]`：12位的立即数。

### S 型指令格式
S 型指令用于内存存储。
```
31       25  24  20  19  15  14  12  11    7  6      0
+---------+-------+-------+-------+---------+---------+
| imm[11:5]|  rs2  |  rs1  | funct3| imm[4:0] | opcode |
+---------+-------+-------+-------+---------+---------+
```
- `opcode`：操作码。
- `imm[4:0]`：立即数的低 5 位。
- `funct3`：功能码。
- `rs1`：第一个源寄存器。
- `rs2`：第二个源寄存器。
- `imm[11:5]`：立即数的高 7 位。

### B 型指令格式
B 型指令用于条件分支。
```
31      31 30       25 24  20 19 15 14   12 11       7 6        6         0
+---------+-----------+-----+-----+--------+----------+---------+--------+
| imm[12] | imm[10:5] | rs2 | rs1 | funct3 | imm[4:1] | imm[11] | opcode |
+---------+-----------+-----+-----+--------+----------+---------+--------+
```
- `opcode`：操作码。
- `imm[11]`：立即数第 11 位。
- `imm[4:1]`：立即数的第 4 到第 1 位。
- `funct3`：功能码。
- `rs1`：第一个源寄存器。
- `rs2`：第二个源寄存器。
- `imm[10:5]`：立即数的第 10 到第 5 位。
- `imm[12]`：立即数的第 12 位。

### U 型指令格式
U 型指令用于加载高位立即数。
```
31         12  11  7  6      0
+------------+-----+---------+
| imm[31:12] |  rd | opcode  |
+------------+-----+---------+
```
- `opcode`：操作码。
- `rd`：目标寄存器。
- `imm[31:12]`：立即数的13位到32位。

### J 型指令格式
J 型指令用于无条件跳转。
```
31     31 30       21 20   20 19       12 11 7 6       0
+--------+----------+--------+-----------+----+--------+
|imm[20] |imm[10:1] |imm[11] |imm[19:12] | rd | opcode |
+--------+----------+--------+-----------+----+--------+
```
- `opcode`：操作码。
- `rd`：目标寄存器。
- `imm[19:12]`：立即数的第19 到第 12 位。
- `imm[11]`：立即数的第11 位。
- `imm[10:1]`：立即数的第10 到第 1 位。
- `imm[20]`：立即数的第20 位。

### 对比
S 和 B 格式之间的唯一区别在于，B 格式中使用 12 位立即数字段来编码 2 的倍数的分支偏移量。中间位 (imm[10:1]) 和符号位保留在固定位置，而 S 格式中的最低位 (inst[ 7]) 以 B 格式对高位进行编码。

U 和 J 格式之间的唯一区别在于，20 位立即数左移 12 位以形成 U 立即数，左移 1 位以形成 J 立即数。 U 和 J 格式立即数中指令位的位置被选择为最大化与其他格式以及彼此之间的重叠。

## RV32I

对于 RV32I，32 个 x 寄存器每个都是 32 位宽 。寄存器 x0 被硬连线，所有位都等于 0。通用寄存器 x1-x31 保存各种指令解释为布尔值集合、或二进制补码有符号二进制整数或无符号二进制的值整数。还有一个程序计数器 pc 保存当前指令的地址。
在基本 RV32I ISA 中，有四种核心指令格式（R/I/S/U），如基本指令格式中所示。所有的长度都是固定的 32 位。基本 ISA 具有 `IALIGN=32` ，这意味着指令必须在内存中的四字节边界上对齐。如果目标地址未 IALIGN-bit 对齐，则在执行分支或无条件跳转时会生成指令地址未对齐异常。此异常是在分支或跳转指令上报告的，而不是在目标指令上报告的。对于未采用的条件分支，不会生成指令地址未对齐异常。

可选的压缩 16 位指令格式是围绕以下假设而设计的： x1 是返回地址寄存器， x2 是堆栈指针。使用其他约定的软件将正确运行，但可能具有更大的代码大小。

### I 型指令集
主要用于立即数运算和内存加载操作

| 指令   | 描述                      | opcode  | funct3 |
|--------|---------------------------|---------|--------|
| ADDI   | 加立即数                  | 0010011 | 000    |
| SLTI   | 小于立即数置位（有符号）  | 0010011 | 010    |
| SLTIU  | 小于立即数置位（无符号）  | 0010011 | 011    |
| XORI   | 按位异或立即数            | 0010011 | 100    |
| ORI    | 按位或立即数              | 0010011 | 110    |
| ANDI   | 按位与立即数              | 0010011 | 111    |
| SLLI   | 逻辑左移立即数            | 0010011 | 001    |
| SRLI   | 逻辑右移立即数            | 0010011 | 101    |
| SRAI   | 算术右移立即数            | 0010011 | 101    |
| LB     | 加载字节                  | 0000011 | 000    |
| LH     | 加载半字                  | 0000011 | 001    |
| LW     | 加载字                    | 0000011 | 010    |
| LBU    | 加载无符号字节            | 0000011 | 100    |
| LHU    | 加载无符号半字            | 0000011 | 101    |
| JALR   | 跳转并链接寄存器          | 1100111 | 000    |

#### ADDI

将符号扩展的12位立即数加上寄存器rs1得值。忽略算术溢出，将结果的低XLEN位保存到寄存器rd。`addi rd, rs1, 0`实现类似`mv rd, rs1`汇编伪指令, `nop`伪指令实现`addi x0, x0, 0`。

#### SLTI

如果寄存器 rs1 小于符号扩展立即数（且两者均被视为有符号数），则 SLTI（设置小于立即数）将值 1 放入寄存器 rd，否则将 0 写入 rd。

#### SLTIU

立即数首先被符号扩展为 XLEN 位，然后被视为无符号数, 如果寄存器 rs1 小于立即数（且两者均被视为无符号数），则 SLTI（设置小于立即数）将值 1 放入寄存器 rd，否则将 0 写入 rd。`sltiu rd, rs1, 1` 如果rs1为0, 则rd设置为1, 实现汇编伪指令`seqz rd, rs`

#### ANDI,ORI,XORI 

ANDI、ORI、XORI 是逻辑运算，对寄存器 rs1 和符号扩展的 12 位立即数执行按位 AND、OR 和 XOR，并将结果放入 rd。`xori rd, rs1, -1`将rs1的值取反, 实现汇编伪指令`not rd, rs`

#### SLLI,SRLI,SRAI

移位常数被编码为 I 类型格式的特化。要移位的操作数在rs1中，移位量编码在立即数字段的低5位中。右移类型编码在位 30 中(0为SRLI, 1为SRAI)。SLLI 是逻辑左移（零移入低位）； SRLI 是逻辑右移（零移入高位）； SRAI是算术右移（将原来的符号位复制到空出的高位中）。

#### LB
`lb rd, offset(rs1)`从rs1加上立即数的内存地址中加载一个8位值，然后符号扩展为32位，保存到寄存器rd中。

#### LH
`lh rd, offset(rs1)`从rs1加上立即数的内存地址中加载一个16位值，然后符号扩展为32位，保存到寄存器rd中。

#### LW
`lw rd, offset(rs1)`从rs1加上立即数的内存地址中加载一个32位值，保存到寄存器rd中。

#### LBU
`lbu rd, offset(rs1)`从rs1加上立即数的内存地址中加载一个8位值，然后零扩展为32位，保存到寄存器rd中。

#### LHU
`lhu rd, offset(rs1)`从rs1加上立即数的内存地址中加载一个16位值，然后零扩展为32位，保存到寄存器rd中。

#### JALR
过将符号扩展的 12 位立即数与寄存器 rs1 相加，然后将结果的最低有效位设置为零来获得目标地址。返回地址(pc +4)被写入寄存器 rd。如果不需要结果，寄存器 x0 可以用作目标。
LUI 指令可以首先将目标地址的高 20 位装入 rs1，然后 JALR 可以添加低位。类似地，AUIPC 然后 JALR 可以跳转到 32 位 pc 相对地址范围内的任何位置。


### U 型指令集
U 型指令格式（U 型指令）在 RISC-V 中用于加载高位立即数到寄存器。

| 指令       | 描述                                    | opcode  | 格式   |
|------------|-----------------------------------------|---------|--------|
| LUI        | 加载高位立即数                          | 0110111 | U 型   |
| AUIPC      | 加载上半立即数加 PC                      | 0010111 | U 型   |


#### LUI
LUI（加载立即数）用于构建32位常量并使用U型格式。 LUI 将 32 位 U 立即值放入目标寄存器 rd，并用零填充最低 12 位。

#### AUIPC

用于构建 pc 相对地址并使用 U 型格式。 AUIPC 从 U 立即数形成一个 32 位偏移量，用零填充最低 12 位，将该偏移量与 PC 相加，然后将结果放入寄存器 rd 中。

### R 型指令集

R 型指令集用于寄存器之间的算术和逻辑运算。每条 R 型指令都使用两个源寄存器和一个目标寄存器，并且有一个功能码（funct3）和一个扩展功能码（funct7）

| 指令   | 描述          | funct7  | funct3 | opcode  |
|--------|---------------|---------|--------|---------|
| ADD    | 加法          | 0000000 | 000    | 0110011 |
| SUB    | 减法          | 0100000 | 000    | 0110011 |
| SLL    | 逻辑左移      | 0000000 | 001    | 0110011 |
| SRL    | 逻辑右移      | 0000000 | 101    | 0110011 |
| SRA    | 算术右移      | 0100000 | 101    | 0110011 |
| SLT    | 小于（有符号）| 0000000 | 010    | 0110011 |
| SLTU   | 小于（无符号）| 0000000 | 011    | 0110011 |
| XOR    | 按位异或      | 0000000 | 100    | 0110011 |
| OR     | 按位或        | 0000000 | 110    | 0110011 |
| AND    | 按位与        | 0000000 | 111    | 0110011 |


#### ADD

`rd = r1 + r2`

#### SUB
`rd = r1 - r2`溢出被忽略，结果的低 XLEN 位被写入目标 rd。

#### SLL,SRL,SRA
SLL、SRL 和 SRA 对寄存器 rs1 中的值执行逻辑左移、逻辑右移和算术右移，移位量为寄存器 rs2 低 5 位中保存的移位量。

#### SLT,SLTU
SLT 和 SLTU 分别执行有符号和无符号比较，如果 rs1 < rs2，则将 1 写入 rd，否则写入 0。

#### XOR,OR,AND
XOR, OR和AND执行按位逻辑运算。

### J 型指令集
J 型指令（Jump 型指令）用于无条件跳转

| 指令       | 描述                                    | opcode  | 格式   |
|------------|-----------------------------------------|---------|--------|
| JAL        | 跳转和链接                               | 0000111 | J 型   | 

#### JAL
其中 J 立即数以 2 字节的倍数编码有符号偏移量。将偏移量进行符号扩展并与PC相加，形成跳转目标地址。因此，跳转可以瞄准 ±1 MiB 范围。 JAL将返回地址 ('pc'+4) 存储到寄存器 rd 中。标准软件调用约定使用“x1”作为返回地址寄存器，使用“x5”作为备用链接寄存器。

### B 型指令集

B 型指令（Branch 型指令）用于条件分支跳转。12位立即数以2字节的倍数编码有符号偏移量。偏移量被符号扩展并添加到分支指令的地址以给出目标地址。条件分支范围为±4 KiB。

| 指令   | 描述                                    | funct3 | opcode  |
|--------|-----------------------------------------|--------|---------|
| BEQ    | 等于则分支                              | 000    | 1100011 |
| BNE    | 不等则分支                              | 001    | 1100011 |
| BLT    | 小于则分支                              | 100    | 1100011 |
| BGE    | 大于等于则分支                          | 101    | 1100011 |
| BLTU   | 无符号小于则分支                        | 110    | 1100011 |
| BGEU   | 无符号大于等于则分支                    | 111    | 1100011 |

#### BEQ
如果寄存器 rs1 和 rs2 分别相等，则采取分支。

#### BNE
如果寄存器 rs1 和 rs2 分别不相等，则采取分支。

#### BLT
有符号比较, 如果rs1小于rs2, 则采取分支。

#### BGE
有符号比较, 如果rs1大于rs2, 则采取分支。

#### BLTU
无符号比较, 如果rs1小于rs2, 则采取分支。

#### BGEU
无符号比较, 如果rs1大于rs2, 则采取分支。

### S 型指令集

S 型指令用于存储数据到内存中。每条 S 型指令使用两个源寄存器，其中一个寄存器提供基地址，另一个寄存器提供存储的数据，以及一个立即数提供偏移量。

以下是 RISC-V 中常见的 S 型指令及其功能描述：

| 指令   | 描述                      | funct3 | opcode  |
|--------|---------------------------|--------|---------|
| SB     | 存储字节                  | 000    | 0100011 |
| SH     | 存储半字                  | 001    | 0100011 |
| SW     | 存储字                    | 010    | 0100011 |

#### SB
`sb rs2, offset(rs1)`将`rs2`的低8位字节存储到以`rs1`为基地址加上`立即数偏移`的位置。

#### SH
`sh rs2, offset(rs1)`将`rs2`的低16位字节存储到以`rs1`为基地址加上`立即数偏移`的位置。

#### SW
`sw rs2, offset(rs1)`将`rs2`的32位字节存储到以`rs1`为基地址加上`立即数偏移`的位置。

## RV32E和RV64E

RV32E和RV64E分别是RV32I和RV64I的缩减版本：唯一的变化是将整数寄存器的数量减少到 16 个( x0-x15 )，其中 x0 是专用零寄存器。

## RV64I

提供了其他指令变体来操作 RV64I 中的 32 位值，由操作码后缀“W”表示。这些“*W”指令忽略其输入的高 32 位，并始终生成 32 位有符号值，将它们符号扩展为 64 位，所有 32 位值都以符号扩展格式保存在 64 位寄存器中。即使 32 位无符号整数也会将位 31 扩展到位 63 到 32。因此，无符号和有符号 32 位整数之间的转换是无操作的，就像从有符号 32 位整数到有符号 64 位整数的转换一样。

### ADDIW

它将符号扩展的12位立即数与寄存器rs1相加, 结果的低32位符号扩展为64保存到寄存器rd。

### SLLI,SRLI,SRAI

SLL、SRL 和 SRA 对寄存器rs1中的值执行逻辑左移、逻辑右移和算术右移，移位量为寄存器rs2低`6`位中保存的移位量。

### SLLIW,SRLIW,SRAIW

与SLLI,SRLI,SRAI类似, 但对32位值进行操作并将其32位结果符号扩展为64位。 imm[5] ≠ 0 的 SLLIW、SRLIW 和 SRAIW 编码被保留。

### LUI

使用与 RV32I 相同的操作码。 LUI将32位立即数放入寄存器rd中，并用零填充最低12位。 32位结果被符号扩展为 64 位。

### AUIPC

使用与 RV32I相同的操作码。 AUIPC用于构建pc相对地址并使用U型格式。 AUIPC从U立即数形成32位偏移量，用零填充最低12位，将结果符号扩展为 64 位，将其加上PC，然后将结果放入寄存器rd中。

### ADDW, SUBW

其定义与 ADD 和 SUB 类似，但对 32 位值进行操作并生成带符号的 32 位结果。溢出被忽略，结果的低 32 位被符号扩展为 64 位并写入目标寄存器。

### SLL,SRL,SRA

在RV64I中，仅考虑rs2的低`6`位作为移位量。

### SLLW,SRLW,SRAW

在RV64I中，移位量由 rs2[4:0] 给出。

### LD

I 型指令, 将64位值从内存加载到寄存器rd中。

| 指令   | 描述                                | funct3 | opcode  |
|--------|-------------------------------------|--------|---------|
| LD     | 从内存加载一个 64 位的双字到寄存器 | 011    | 0000011 |

### SD

### SD 指令

S 型指令, 将一个 64 位的双字（doubleword）存储到内存中。


| 指令   | 描述                                | funct3 | opcode  |
|--------|-------------------------------------|--------|---------|
| SD     | 将 64 位双字存储到内存中            | 011    | 0100011 |


## RV128I

RV128I 以与 RV64I 构建于 RV32I 相同的方式构建于 RV64I 之上，其中整数寄存器扩展至 128 位（即 XLEN=128）。大多数整数计算指令都保持不变，因为它们被定义为在 XLEN 位上运行。对寄存器低位中的 32 位值进行操作的 RV64I“*W”整数指令被保留，但现在将其结果从位 31 符号扩展到位 127。添加了一组新的“*D”整数指令，对 128 位整数寄存器的低位中保存的 64 位值进行操作，并将其结果从第 63 位符号扩展到第 127 位。“*D”指令使用两个主要操作码（OP-IMM-64 和 OP-64） ）采用标准 32 位编码。

## Zifencei拓展

RISC-V 的 Zifencei 扩展增加了指令和内存顺序模型中的 FENCE.I 指令，用于确保指令流在内存模型中的一致性。这在处理自修改代码或共享内存的系统中尤其重要。

#### 作用
`FENCE.I`（Instruction Fence）是 I 型指令, 指令用于确保在执行该指令之前的所有内存写操作（特别是代码段的写操作）在接下来的指令取指操作之前生效。这在处理自修改代码时非常重要，确保 CPU 知道已经更新了指令并且这些更改在下一次指令取指时生效。

#### 指令描述

| 指令    | 描述                                        | funct3 | opcode  |
|---------|---------------------------------------------|--------|---------|
| FENCE.I | 确保之前的内存写操作在接下来的指令取指之前生效 | 000    | 0001111 |

### 示例指令和解释

#### FENCE.I
- **描述**：确保在执行该指令之前的所有内存写操作在接下来的指令取指操作之前生效。
- **格式**：`FENCE.I`
- **机器码**：
  ```
  31      20  19   15  14  12  11   7  6      0
  +---------+-------+-----+-----+-------+--------+
  | 000000000000 |  00000  | 000 | 00000 | 0001111 |
  +---------+-------+-----+-----+-------+--------+
  ```

### 示例说明

在某些情况下，例如动态生成代码或修改已经加载的指令，使用 `FENCE.I` 指令是必需的：

```asm
# 修改内存中某个位置的代码
SW x3, 0(x1)  # 将寄存器 x3 的值存储到内存地址 x1

# 确保之前的写操作对接下来的指令取指操作可见
FENCE.I

# 从内存中执行刚刚写入的指令
JALR x0, 0(x1)
```

### 详细说明

1. **FENCE.I (Instruction Fence)**
   - **描述**：确保所有先前的内存写操作在任何后续的指令取指操作之前完成。
   - **操作码**：0001111
   - **功能码 (funct3)**：000
   - **使用场景**：自修改代码、热补丁、JIT 编译器等需要确保指令流一致性的情况。

### 应用场景

- **自修改代码**：当程序修改自身的代码段时，需要确保修改后的代码在执行时是最新的。
- **JIT 编译**：即时编译器在生成和修改代码后，需要确保 CPU 知道并执行最新的代码。
- **热补丁**：当系统在运行时应用补丁修改指令时，`FENCE.I` 指令确保新指令被正确执行。


## Zicsr拓展

RISC-V 的 Zicsr 扩展增加了对控制状态寄存器（CSR，Control and Status Register）操作的指令集，这些指令用于访问和操作 CPU 内部的控制状态寄存器，以实现各种特权级功能和系统控制功能。

### CSR 指令概述

Zicsr 扩展引入了以下指令，CSR 指令是I型指令，用于读写控制状态寄存器：

1. **CSRRW**：读写 CSR
2. **CSRRS**：读并置位 CSR
3. **CSRRC**：读并清零 CSR
4. **CSRRWI**：立即数读写 CSR
5. **CSRRSI**：立即数读并置位 CSR
6. **CSRRCI**：立即数读并清零 CSR

### CSR 指令描述

| 指令    | 描述                                  | funct3 | opcode  |
|---------|---------------------------------------|--------|---------|
| CSRRW   | 读写 CSR                              | 001    | 1110011 |
| CSRRS   | 读并置位 CSR                          | 010    | 1110011 |
| CSRRC   | 读并清零 CSR                          | 011    | 1110011 |
| CSRRWI  | 立即数读写 CSR                        | 101    | 1110011 |
| CSRRSI  | 立即数读并置位 CSR                    | 110    | 1110011 |
| CSRRCI  | 立即数读并清零 CSR                    | 111    | 1110011 |

### 指令功能

#### CSRRW（CSR Read and Write）
- **描述**：将 CSR 的值读到寄存器 `rd`，然后将寄存器 `rs1` 的值写入 CSR。
- **格式**：`CSRRW rd, csr, rs1`
- **机器码**：
  ```
  31      20  19   15  14  12  11   7  6      0
  +---------+-------+-----+-----+-------+--------+
  |  csr[11:0] |  rs1  | 001 |  rd  | 1110011 |
  +---------+-------+-----+-----+-------+--------+
  ```

#### CSRRS（CSR Read and Set）
- **描述**：将 CSR 的值读到寄存器 `rd`，然后将寄存器 `rs1` 的值按位或到 CSR 中。
- **格式**：`CSRRS rd, csr, rs1`
- **机器码**：
  ```
  31      20  19   15  14  12  11   7  6      0
  +---------+-------+-----+-----+-------+--------+
  |  csr[11:0] |  rs1  | 010 |  rd  | 1110011 |
  +---------+-------+-----+-----+-------+--------+
  ```

#### CSRRC（CSR Read and Clear）
- **描述**：将 CSR 的值读到寄存器 `rd`，然后将寄存器 `rs1` 的值按位取反并按位与到 CSR 中。
- **格式**：`CSRRC rd, csr, rs1`
- **机器码**：
  ```
  31      20  19   15  14  12  11   7  6      0
  +---------+-------+-----+-----+-------+--------+
  |  csr[11:0] |  rs1  | 011 |  rd  | 1110011 |
  +---------+-------+-----+-----+-------+--------+
  ```

#### CSRRWI（CSR Read and Write Immediate）
- **描述**：将 CSR 的值读到寄存器 `rd`，然后将立即数 `uimm` 写入 CSR。
- **格式**：`CSRRWI rd, csr, uimm`
- **机器码**：
  ```
  31      20  19   15  14  12  11   7  6      0
  +---------+-------+-----+-----+-------+--------+
  |  csr[11:0] | uimm | 101 |  rd  | 1110011 |
  +---------+-------+-----+-----+-------+--------+
  ```

#### CSRRSI（CSR Read and Set Immediate）
- **描述**：将 CSR 的值读到寄存器 `rd`，然后将立即数 `uimm` 按位或到 CSR 中。
- **格式**：`CSRRSI rd, csr, uimm`
- **机器码**：
  ```
  31      20  19   15  14  12  11   7  6      0
  +---------+-------+-----+-----+-------+--------+
  |  csr[11:0] | uimm | 110 |  rd  | 1110011 |
  +---------+-------+-----+-----+-------+--------+
  ```

#### CSRRCI（CSR Read and Clear Immediate）
- **描述**：将 CSR 的值读到寄存器 `rd`，然后将立即数 `uimm` 按位取反并按位与到 CSR 中。
- **格式**：`CSRRCI rd, csr, uimm`
- **机器码**：
  ```
  31      20  19   15  14  12  11   7  6      0
  +---------+-------+-----+-----+-------+--------+
  |  csr[11:0] | uimm | 111 |  rd  | 1110011 |
  +---------+-------+-----+-----+-------+--------+
  ```

### 示例指令和解释

假设我们有一个控制状态寄存器 `csr`，其地址为 `0x300`。

#### CSRRW 示例
```asm
csrrw x1, 0x300, x2
```
这条指令会将 CSR 地址 `0x300` 处的值读到寄存器 `x1`，然后将寄存器 `x2` 的值写入 CSR `0x300`。

#### CSRRS 示例
```asm
csrrs x1, 0x300, x2
```
这条指令会将 CSR 地址 `0x300` 处的值读到寄存器 `x1`，然后将寄存器 `x2` 的值按位或到 CSR `0x300` 中。

#### CSRRC 示例
```asm
csrrc x1, 0x300, x2
```
这条指令会将 CSR 地址 `0x300` 处的值读到寄存器 `x1`，然后将寄存器 `x2` 的值按位取反并按位与到 CSR `0x300` 中。

#### CSRRWI 示例
```asm
csrrwi x1, 0x300, 5
```
这条指令会将 CSR 地址 `0x300` 处的值读到寄存器 `x1`，然后将立即数 `5` 写入 CSR `0x300`。

#### CSRRSI 示例
```asm
csrrsi x1, 0x300, 5
```
这条指令会将 CSR 地址 `0x300` 处的值读到寄存器 `x1`，然后将立即数 `5` 按位或到 CSR `0x300` 中。

#### CSRRCI 示例
```asm
csrrci x1, 0x300, 5
```
这条指令会将 CSR 地址 `0x300` 处的值读到寄存器 `x1`，然后将立即数 `5` 按位取反并按位与到 CSR `0x300` 中。

### 应用场景

- **系统控制**：操作系统内核使用 CSR 指令来配置和控制 CPU 状态。
- **异常处理**：处理器在处理中断和异常时，使用 CSR 指令访问和修改异常状态寄存器。
- **性能监控**：通过 CSR 指令访问和控制性能监控计数器。
- **调试**：调试工具使用 CSR 指令来访问调试控制和状态寄存器。

## Zicntr扩展

RISC-V 的 Zicntr 扩展增加了对计数器和定时器的支持。它提供了一组标准的性能计数器和定时器寄存器，这些寄存器可以用来监控和管理处理器的性能。

### 性能计数器和定时器寄存器

以下是 Zicntr 扩展中定义的标准性能计数器和定时器寄存器：

1. **cycle**：用于计数自处理器启动以来的时钟周期数。
2. **time**：用于计数自处理器启动以来的定时器时钟周期数。
3. **instret**：用于计数自处理器启动以来已执行的指令数。

### 访问计数器和定时器寄存器

这些寄存器可以通过 CSR 指令（如 CSRR、CSRW、CSRS、CSRC 等）进行访问。

#### 读取计数器寄存器

对于 XLEN≥64 的基本 ISA，CSR 指令可以直接访问完整的 64 位 CSR。使用rdcycle、rdtime 和 rdinstret伪指令读取 cycle 、 time 和 instret 计数器的完整 64 位。对于 XLEN=32 的基本 ISA，Zicntr 扩展允许以 32 位片的形式访问三个64位只读计数器。 rdcycle、rdtime 和 rdinstret伪指令提供各自计数器的低 32 位，rdcycleh、rdtimeh 和 rdinstreth伪指令提供各自计数器的高 32 位。

- 读取 `cycle` 寄存器：
  ```asm
  csrrci x1, cycle, 0
  rdcycle x1
  ```

- 读取 `time` 寄存器：
  ```asm
  csrrci x1, time, 0
  rdtime x1
  ```

- 读取 `instret` 寄存器：
  ```asm
  csrrci x1, instret, 0
  rdinstret x1
  ```

#### 写入计数器寄存器

通常，性能计数器寄存器是只读的，但在某些情况下可以通过操作系统或特权级代码重置这些寄存器。

### 示例代码

#### 读取 `cycle` 计数器
```asm
csrr x1, cycle  # 将cycle计数器的值读入寄存器x1
```

#### 读取 `time` 计数器
```asm
csrr x1, time   # 将time计数器的值读入寄存器x1
```

#### 读取 `instret` 计数器
```asm
csrr x1, instret  # 将instret计数器的值读入寄存器x1
```

### 计数器寄存器地址

在 RISC-V 的控制状态寄存器（CSR）地址空间中，以下是一些常见的性能计数器和定时器寄存器地址：

- `cycle`：CSR 地址 0xC00
- `time`：CSR 地址 0xC01
- `instret`：CSR 地址 0xC02

## Zihintntl拓展

NTL 指令是 HINT，指示紧随其后的指令（下文称为“目标指令”）的显式内存访问表现出较差的引用时间局部性。 NTL指令不改变体系结构状态，也不改变目标指令的体系结构可见效果。提供四种变体：

- NTL.P1指令指示目标指令在存储器层次结构中的最内层私有高速缓存的容量内不表现出时间局部性。 NTL.P1 编码为 `add x0、x0、x2`。
- NTL.PALL指令指示目标指令在存储器层次结构中的任何级别的私有高速缓存的容量内不表现出时间局部性。 NTL.PALL 编码为 `add x0、x0、x3`。
- NTL.S1指令指示目标指令在存储器层次结构中最内层共享高速缓存的容量内不表现出时间局部性。 NTL.S1 编码为 `add x0、x0、x4`。
- NTL.ALL指令指示目标指令在存储器层次结构中的任何级高速缓存的容量内不表现出时间局部性。 NTL.ALL 编码为 `add x0、x0、x5`。

## Zihintpause扩展

RISC-V 的 Zihintpause 扩展增加了一条用于暂停指令执行的提示指令，旨在优化超线程（SMT，Simultaneous Multithreading）环境下的性能。这条指令为处理器提供了在等待期间暂停执行的提示，允许处理器更高效地调度其他线程，从而提高整体系统性能和能效。

### 指令概述

Zihintpause 扩展定义了一条提示指令：

1. **PAUSE**：提示处理器当前线程可以暂停执行，以便处理器调度其他线程。

### PAUSE 指令格式

PAUSE 是一种无操作数的指令，格式如下：

```
31      25  24  20  19  15  14  12  11   7  6   0
+---------+-------+-----+-----+-------+--------+
| 0000000 | 00000 | 000 | 00000 | 0001011 |
+---------+-------+-----+-----+-------+--------+
```

## Zimop拓展

它引入了可能是操作的指令（MOP）的概念。 MOP 最初定义为简单地将零写入 x[rd] ，但设计为由以后的扩展重新定义以执行某些其他操作。 

1. Zimop 扩展定义了 40 个 MOP 的编码空间。Zimop 扩展定义了 32 个名为 MOP.R.n 的 MOP 指令，其中 n 是 0 到 31 之间的整数（含 0 和 31）。除非由另一个扩展重新定义，否则这些指令只是将 0 写入 x[rd] 。它们的编码允许将来的扩展将它们定义为读取 x[rs1] 以及写入 x[rd] 。

2. Zimop 扩展另外定义了 8 个名为 MOP.RR.n 的 MOP 指令，其中 n 是 0 到 7 之间的整数（包含 0 和 7）。除非由另一个扩展重新定义，否则这些指令只是将 0 写入 x[rd] 。它们的编码允许将来的扩展将它们定义为读取 x[rs1] 和 x[rs2] 以及写入 x[rd] 。

## Zicond拓展

Zicond 扩展定义了一种简单的解决方案，它提供了支持条件算术和条件选择/移动操作所需的大部分好处和所有灵活性，同时保持了 RISC-V 设计理念。这些指令遵循具有 3 个操作数（即 2 个源操作数和 1 个目标操作数）的 R 类型指令的格式。使用这些指令，可以实现无分支序列（通常在两个指令序列中），而不需要指令融合、架构指令解码期间的特殊规定或其他微体系结构规定。

| 指令   | 描述          | funct7  | funct3 | opcode  |
|--------|---------------|---------|--------|---------|
| czero.eqz  | 如果条件 rs2 等于 0，则将零移至寄存器 rd，否则将 rs1 移至 rd。  | 0000111 | 101    | 0110011 |
| czero.nez  | 如果条件 rs2 非零，则将零移至寄存器 rd，否则将 rs1 移至 rd。  | 0000111 | 111    | 0110011 |


## M拓展
标准整数乘法和除法指令扩展，包含对两个整数寄存器中保存的值进行乘法或除法的指令。


### M 扩展指令表格

以下是 RISC-V M 扩展（整数乘除扩展）的指令表格，包含每条指令的描述、功能码（funct3 和 funct7）、操作码（opcode）以及指令格式。

| 指令  | 描述 | funct7 | funct3 | opcode | 格式 |
|-------|------|--------|--------|--------|------|
| MUL   | 有符号整数乘法，结果低位存储到 rd 中 | 0000001 | 000 | 0110011 | `MUL rd, rs1, rs2` |
| MULW  | (RV64)有符号整数低32位乘法，结果低位存储到 rd 中 | 0000001 | 000 | 0110011 | `MULH rd, rs1, rs2` |
| MULH  | 高位有符号乘法，结果高位存储到 rd 中 | 0000001 | 001 | 0110011 | `MULH rd, rs1, rs2` |
| MULHSU | 高位有符号和无符号混合乘法，结果高位存储到 rd 中 | 0000001 | 010 | 0110011 | `MULHSU rd, rs1, rs2` |
| MULHU | 高位无符号乘法，结果高位存储到 rd 中 | 0000001 | 011 | 0110011 | `MULHU rd, rs1, rs2` |
| DIV   | 有符号整数除法，商存储到 rd 中 | 0000001 | 100 | 0110011 | `DIV rd, rs1, rs2` |
| DIVU  | 无符号整数除法，商存储到 rd 中 | 0000001 | 101 | 0110011 | `DIVU rd, rs1, rs2` |
| DIVW  | (RV64)有符号整数除法，只运算低32位商存储到 rd 中 | 0000001 | 100 | 0110011 | `DIV rd, rs1, rs2` |
| DIVUW | (RV64)无符号整数除法，只运算低32位商存储到 rd 中 | 0000001 | 101 | 0110011 | `DIVU rd, rs1, rs2` |
| REM   | 有符号整数取余，余数存储到 rd 中 | 0000001 | 110 | 0110011 | `REM rd, rs1, rs2` |
| REMU  | 无符号整数取余，余数存储到 rd 中 | 0000001 | 111 | 0110011 | `REMU rd, rs1, rs2` |
| REMW   | (RV64)有符号整数取余，只运算低32位余数存储到 rd 中 | 0000001 | 110 | 0110011 | `REM rd, rs1, rs2` |
| REMUW  | (RV64)无符号整数取余，只运算低32位余数存储到 rd 中 | 0000001 | 111 | 0110011 | `REMU rd, rs1, rs2` |

## Zmmul拓展

Zmmul 扩展实现了 M 扩展的乘法子集。它添加了第 13.1 节中定义的所有指令，即：MUL、MULH、MULHU、MULHSU 和（仅适用于 RV64）MULW。这些编码与相应的 M 扩展指令的编码相同。 M 意味着 Zmmul。

## Zaamo拓展
原子内存操作 (AMO) 指令执行读-修改-写操作以实现多处理器同步，并使用 R 型指令格式进行编码。这些 AMO 指令以原子方式从 rs1 中的地址加载数据值，将该值放入寄存器 rd，对加载的值和 rs2 中的原始值应用二元运算符，然后将结果存储回 rs1 中的原始地址。 AMO 可以对双字（仅限 RV64）或内存中的字进行操作。对于 RV64，32 位 AMO 始终对 rd 中的值进行符号扩展，并忽略 rs2 原始值的高 32 位。

### 指令表格

| 指令         | 描述                                                         | funct7 | funct3 | opcode  | 格式                      |
|--------------|--------------------------------------------------------------|--------|--------|---------|---------------------------|
| **AMOADD.W** | 将 `rs2` 的值与内存地址 `rs1` 的值相加，并将结果写回内存，同时将内存中的原始值存储到 `rd` 中 | 00001  | 010    | 0101111 | `AMOADD.W rd, rs2, (rs1)` |
| **AMOXOR.W** | 将 `rs2` 的值与内存地址 `rs1` 的值进行异或，并将结果写回内存，同时将内存中的原始值存储到 `rd` 中 | 00001  | 100    | 0101111 | `AMOXOR.W rd, rs2, (rs1)` |
| **AMOAND.W** | 将 `rs2` 的值与内存地址 `rs1` 的值进行与操作，并将结果写回内存，同时将内存中的原始值存储到 `rd` 中 | 00001  | 011    | 0101111 | `AMOAND.W rd, rs2, (rs1)` |
| **AMOOR.W**  | 将 `rs2` 的值与内存地址 `rs1` 的值进行或操作，并将结果写回内存，同时将内存中的原始值存储到 `rd` 中 | 00001  | 010    | 0101111 | `AMOOR.W rd, rs2, (rs1)`  |
| **AMOMIN.W** | 将 `rs2` 和内存地址 `rs1` 的值比较，取最小值写回内存，同时将内存中的原始值存储到 `rd` 中 | 00001  | 100    | 0101111 | `AMOMIN.W rd, rs2, (rs1)` |
| **AMOMAX.W** | 将 `rs2` 和内存地址 `rs1` 的值比较，取最大值写回内存，同时将内存中的原始值存储到 `rd` 中 | 00001  | 101    | 0101111 | `AMOMAX.W rd, rs2, (rs1)` |
| **AMOMINU.W**| 将 `rs2` 和内存地址 `rs1` 的无符号值比较，取最小值写回内存，同时将内存中的原始值存储到 `rd` 中 | 00001  | 110    | 0101111 | `AMOMINU.W rd, rs2, (rs1)`|
| **AMOMAXU.W**| 将 `rs2` 和内存地址 `rs1` 的无符号值比较，取最大值写回内存，同时将内存中的原始值存储到 `rd` 中 | 00001  | 111    | 0101111 | `AMOMAXU.W rd, rs2, (rs1)`|
| **AMOADD.D** | 将 `rs2` 的值与内存地址 `rs1` 的值相加，并将结果写回内存，同时将内存中的原始值存储到 `rd` 中 | 00001  | 011    | 0101111 | `AMOADD.D rd, rs2, (rs1)` |
| **AMOXOR.D** | 将 `rs2` 的值与内存地址 `rs1` 的值进行异或，并将结果写回内存，同时将内存中的原始值存储到 `rd` 中 | 00001  | 111    | 0101111 | `AMOXOR.D rd, rs2, (rs1)` |
| **AMOAND.D** | 将 `rs2` 的值与内存地址 `rs1` 的值进行与操作，并将结果写回内存，同时将内存中的原始值存储到 `rd` 中 | 00001  | 011    | 0101111 | `AMOAND.D rd, rs2, (rs1)` |
| **AMOOR.D**  | 将 `rs2` 的值与内存地址 `rs1` 的值进行或操作，并将结果写回内存，同时将内存中的原始值存储到 `rd` 中 | 00001  | 010    | 0101111 | `AMOOR.D rd, rs2, (rs1)`  |
| **AMOMIN.D** | 将 `rs2` 和内存地址 `rs1` 的值比较，取最小值写回内存，同时将内存中的原始值存储到 `rd` 中 | 00001  | 100    | 0101111 | `AMOMIN.D rd, rs2, (rs1)` |
| **AMOMAX.D** | 将 `rs2` 和内存地址 `rs1` 的值比较，取最大值写回内存，同时将内存中的原始值存储到 `rd` 中 | 00001  | 101    | 0101111 | `AMOMAX.D rd, rs2, (rs1)` |
| **AMOMINU.D**| 将 `rs2` 和内存地址 `rs1` 的无符号值比较，取最小值写回内存，同时将内存中的原始值存储到 `rd` 中 | 00001  | 110    | 0101111 | `AMOMINU.D rd, rs2, (rs1)`|
| **AMOMAXU.D**| 将 `rs2` 和内存地址 `rs1` 的无符号值比较，取最大值写回内存，同时将内存中的原始值存储到 `rd` 中 | 00001  | 111    | 0101111 | `AMOMAXU.D rd, rs2, (rs1)`|


## Zalrsc拓展

用于加载保留/存储条件指令

### 指令表格

| 指令        | 描述                                                         | funct7 | funct3 | opcode  | 格式                  |
|-------------|--------------------------------------------------------------|--------|--------|---------|-----------------------|
| **LR.W**    | 加载保留                                                     | 00010  | 011    | 0101111 | `LR.W rd, (rs1)`      |
| **SC.W**    | 存储条件                                                     | 00011  | 011    | 0101111 | `SC.W rd, rs2, (rs1)` |
| **LR.D**    | 加载保留双字                                                 | 00010  | 011    | 0101111 | `LR.D rd, (rs1)`      |
| **SC.D**    | 存储条件双字                                                 | 00011  | 011    | 0101111 | `SC.D rd, rs2, (rs1)` |


## A拓展

包含原子读取-修改-写入内存的指令，以支持在同一内存空间中运行的多个 RISC-V hart 之间的同步。提供的两种形式的原子指令是加载保留/存储条件指令和原子获取和操作存储器指令。这些原子指令都是 R 型指令，两种类型的原子指令都支持各种内存一致性排序，包括无序、获取、释放和顺序一致语义。这些指令允许 RISC-V 支持 RCsc 内存一致性模型。 A 扩展包含 Zaamo 和 Zalrsc 扩展提供的指令。


## Zawrs拓展




